#!/bin/bash
#
# Symmetrical AES-256 encryption using openssl. Now available in your shell.
#
# Why? Because some idiots with "power" are trying to outlaw end-to-end strong
# cryptography. And they coercing other countries to do the same:
#
#    https://istart.com.au/news-items/five-eyes-continue-battle-for-encryption-backdoors/
# 
# Software developers should "remove end-to-end cryptography" from their 
# systems? That's ludicrous. An attack on all of us. The best way we can fight
# back is by implementing it at all levels we can. And if only plaintext 
# becomes the environment, let's slap encrypted messages into it.
#
# Of course, you could have used plain openssl and terminal skills with it. 
# But since the syntax is a little hard to interpret, this script is handy.
#
# USAGE: quickcrypt [-d] [CIPHERTEXT]
# Pass '-d' to decrypt CIPHERTEXT.
# Reads the message from stdin (you can also pipe it).
#
# ---
#
# Copyright 2020 - Klaus J Zimmermann - https://tilde.town/~kzimmermann
#
# This program is Free Software released under the terms and conditions of the
# GNU GPL v3. You are encouraged to share, modify, improve and re-release it as
# much as possible. See https://gnu.org/licenses for more information.
#
# ---

#------- SETTINGS -------

# Your encryption / decryption passphrase.
# Set something strong here, random. preferrably machine-generated through a
# command like `openssl rand 41 | base64`
KEY=""

# I think this is one of the strongest cipher and hash combination ever, but
# feel free to change it to taste!
COMMAND="openssl enc -aes-256-cbc -base64 -pbkdf2 "

#------- /SETTINGS -------

if [[ "$KEY" == "" ]]
then
    cat <<EOF
Error: passphrase is not defined.

If this is your first time running this program, please take the time to edit
the following line and set it to your passphrase:

KEY=""

Remember that this will be used to encrypt and decrypt ALL your messages, so
make sure it's as strong as possible! It's a good idea to use a random 
passphrase, like those generated by a command like this:

openssl rand 40 | base64

Afterwards, please try again!
EOF
    exit 1
fi

DECRYPT=0

if [[ "$1" == '-d' ]]
then
    DECRYPT=1
fi

# Respect pipes, they make your life easier... 
# and also probably can handle a lot more data than an input line
if [ ! -p /dev/stdin ]
then
    printf "Enter your message: "
fi
read message

echo ""

if [[ "$DECRYPT" == 0 ]]
then
    # I remove newlines from the base64 format because they are easier
    # to copy and paste in terminal multiplexer.
    ciphertext=$(printf "$message" | $COMMAND -k "$KEY" | tr -d "\n")

    # A little more friendly for the user to paste this around
    if [ -n $(which xsel) ]
    then
        printf "$ciphertext" | xsel
        echo "Message copied to clipboard."
    else
        echo $ciphertext
    fi
else
    echo "$message" | $COMMAND -k "$KEY" -d
    echo ""
    exit 0
fi
